import 'mocha';
import * as sinon from 'sinon';

import { ArtifactGenerated, DomainEvent, } from '../../../../src/events';
import { Artifact, FileSystem, FileType, Path } from '../../../../src/io';
import { Duration, Name } from '../../../../src/model';
import { ArtifactArchiver, StageManager } from '../../../../src/stage';

import { expect } from '../../../expect';
import { photo } from '../samples';

describe('ArtifactArchiver', () => {

    let stageManager:   StageManager,
        fs:             sinon.SinonStubbedInstance<FileSystem>,
        archiver:       ArtifactArchiver;

    beforeEach(() => {
        fs       = sinon.createStubInstance(FileSystem);
        fs.store.returns(Promise.resolve(new Path('/some/absolute/path/to/the/artifact')));
    });

    describe('stores the artifacts generated by the other stage crew members', () => {

        beforeEach(() => {
            stageManager = new StageManager(Duration.ofMillis(250));

            archiver = new ArtifactArchiver(fs as any);
            archiver.assignTo(stageManager);
            stageManager.register(archiver);
        });

        const
            artifactName  = new Name('expected-file-name'),
            json = { key: 'value' },
            expectedJsonFilename = [ artifactName.value, FileType.JSON.extesion.value ].join('.'),
            expectedPngFilename  = [ artifactName.value, FileType.PNG.extesion.value ].join('.');

        it('notifies the StageManager when an artifact is saved so that the promise of a stage cue can be fulfilled', () => {
            stageManager.notifyOf(
                new ArtifactGenerated(new Artifact(artifactName, FileType.JSON, json)),
            );

            return expect(stageManager.waitForNextCue()).to.be.fulfilled;
        });

        it('notifies the StageManager when an artifact cannot be saved so that the promise of a stage cue can be rejected', () => {
            fs.store.returns(Promise.reject(new Error('Something happened')));

            stageManager.notifyOf(
                new ArtifactGenerated(new Artifact(artifactName, FileType.PNG, photo.value)),
            );

            return expect(stageManager.waitForNextCue()).to.be.rejected;
        });

        it('correctly saves JSON content to a file', () => {
            stageManager.notifyOf(
                new ArtifactGenerated(new Artifact(artifactName, FileType.JSON, json)),
            );

            return stageManager.waitForNextCue().then(() => {
                expect(fs.store).to.have.been.calledWith(new Path(expectedJsonFilename), JSON.stringify(json));
            });
        });

        it('correctly saves PNG content to a file', () => {
            stageManager.notifyOf(
                new ArtifactGenerated(new Artifact(artifactName, FileType.PNG, photo.value)),
            );

            return stageManager.waitForNextCue().then(() => {
                expect(fs.store).to.have.been.calledWith(new Path(expectedPngFilename), photo.value, 'base64');
            });
        });
    });

    describe(`when it encounters events it's not interested in`, () => {

        class SomeEvent extends DomainEvent {
            constructor() {
                super();
            }
        }

        const someEvent = new SomeEvent();

        it(`ignores them`, () => {
            fs           = sinon.createStubInstance(FileSystem);
            stageManager = sinon.createStubInstance(StageManager) as any;

            archiver     = new ArtifactArchiver(fs as any);
            archiver.assignTo(stageManager as any);

            archiver.notifyOf(
                someEvent,
            );

            expect(stageManager.notifyOf).to.not.have.been.called;            // tslint:disable-line:no-unused-expression
            expect(fs.store).to.not.have.been.called;                         // tslint:disable-line:no-unused-expression
        });
    });
});
