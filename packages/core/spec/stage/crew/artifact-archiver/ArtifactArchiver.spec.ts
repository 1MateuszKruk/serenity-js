import 'mocha';
import * as sinon from 'sinon';

import { Actor } from '../../../../src';
import { ArtifactArchived, ArtifactGenerated, DomainEvent } from '../../../../src/events';
import { FileSystem, Path } from '../../../../src/io';
import { Duration, JSONData, Name, TestReport } from '../../../../src/model';
import { ArtifactArchiver, Cast, Stage, StageManager } from '../../../../src/stage';

import { expect } from '../../../expect';
import { photo } from '../samples';

/** @test {ArtifactArchiver} */
describe('ArtifactArchiver', () => {

    let stage:          Stage,
        fs:             sinon.SinonStubbedInstance<FileSystem>,
        archiver:       ArtifactArchiver;

    const dummies: Cast = {
        actor: (name: string): Actor => null,
    };

    beforeEach(() => {
        fs = sinon.createStubInstance(FileSystem);
        fs.store.callsFake((path: Path, contents: any) => Promise.resolve(path));
    });

    describe('stores the artifacts generated by the other stage crew members', () => {

        beforeEach(() => {
            stage = new Stage(dummies, new StageManager(Duration.ofMillis(250)));

            archiver = new ArtifactArchiver(fs as any, stage);
            stage.assign(archiver);
        });

        const
            json = { key: 'value' },
            jsonArtifactName = new Name('expected-json-artifact-name'),
            pngArtifactName  = new Name('expected-png-artifact-name');

        /**
         * @test {ArtifactArchiver}
         * @test {ArtifactGenerated}
         */
        it('notifies the StageManager when an artifact is saved so that the promise of a stage cue can be fulfilled', () => {
            stage.manager.notifyOf(new ArtifactGenerated(
                jsonArtifactName,
                JSONData.fromJSON(json),
            ));

            return expect(stage.manager.waitForNextCue()).to.be.fulfilled;
        });

        /**
         * @test {ArtifactArchiver}
         * @test {ArtifactGenerated}
         */
        it('notifies the StageManager when an artifact cannot be saved so that the promise of a stage cue can be rejected', () => {
            fs.store.returns(Promise.reject(new Error('Something happened')));

            stage.manager.notifyOf(new ArtifactGenerated(
                pngArtifactName,
                photo,
            ));

            return expect(stage.manager.waitForNextCue()).to.be.rejected;
        });

        /**
         * @test {ArtifactArchiver}
         * @test {ArtifactGenerated}
         */
        it('correctly saves the test report to a unique file', () => {
            stage.manager.notifyOf(new ArtifactGenerated(
                jsonArtifactName,
                TestReport.fromJSON(json),
            ));

            return stage.manager.waitForNextCue().then(() => {
                expect(fs.store).to.have.been.calledWith(
                    new Path(`${jsonArtifactName.value}-b283bd69b0fcd75d754f678ac6685786.json`),
                    JSON.stringify(json),
                );
            });
        });

        /**
         * @test {ArtifactArchiver}
         * @test {ArtifactGenerated}
         */
        it('correctly saves PNG content to a file', () => {
            stage.manager.notifyOf(new ArtifactGenerated(
                pngArtifactName,
                photo,
            ));

            return stage.manager.waitForNextCue().then(() => {
                expect(fs.store).to.have.been.calledWith(
                    new Path(`${pngArtifactName.value}-4fdc8acbf8f6c958b2726fc8ae435bf5.png`),
                    photo.base64EncodedValue,
                    'base64',
                );
            });
        });
    });

    describe(`when it encounters events it's not interested in`, () => {

        class SomeEvent extends DomainEvent {
            constructor() {
                super();
            }
        }

        const someEvent = new SomeEvent();

        /**
         * @test {ArtifactArchiver}
         */
        it(`ignores them`, () => {
            const stageManager = sinon.createStubInstance(StageManager);

            fs           = sinon.createStubInstance(FileSystem);
            stage        = new Stage(dummies, stageManager as unknown as StageManager);

            archiver     = new ArtifactArchiver(fs as any);
            stage.assign(archiver);

            archiver.notifyOf(
                someEvent,
            );

            expect(stageManager.notifyOf).to.not.have.been.called;            // tslint:disable-line:no-unused-expression
            expect(fs.store).to.not.have.been.called;                         // tslint:disable-line:no-unused-expression
        });
    });

    /**
     * @test {ArtifactArchiver}
     * @test {ArtifactGenerated}
     * @test {ArtifactArchived}
     */
    it('notifies the StageManager when the artifact is correctly archived', () => {

        const stageManager = new StageManager(Duration.ofMillis(250));

        stage = new Stage(dummies, stageManager);

        archiver = new ArtifactArchiver(fs as any);
        stage.assign(archiver);

        const notifyOf = sinon.spy(stageManager, 'notifyOf');

        stageManager.notifyOf(new ArtifactGenerated(
            new Name('report'),
            TestReport.fromJSON({ key: 'value' }),
        ));

        return expect(stageManager.waitForNextCue()).to.be.fulfilled.then(() => {

            const archived: ArtifactArchived = notifyOf.getCall(2).lastArg;

            expect(archived).to.be.instanceOf(ArtifactArchived);
            expect(archived.name).to.equal(new Name('report'));
            expect(archived.type).to.equal(TestReport);
            expect(archived.path).to.equal(new Path('report-b283bd69b0fcd75d754f678ac6685786.json'));
        });
    });
});
