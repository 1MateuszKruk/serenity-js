import 'mocha';
import * as sinon from 'sinon';

import { Actor } from '../../../../src';
import { ArtifactArchived, ArtifactGenerated, DomainEvent } from '../../../../src/events';
import { FileSystem, Path } from '../../../../src/io';
import { Duration, JSONData, Name, TestReport } from '../../../../src/model';
import { ArtifactArchiver, Clock, DressingRoom, Stage, StageManager } from '../../../../src/stage';

import { expect } from '../../../expect';
import { photo } from '../samples';

/** @test {ArtifactArchiver} */
describe('ArtifactArchiver', () => {

    let stage:          Stage,
        fs:             sinon.SinonStubbedInstance<FileSystem>,
        archiver:       ArtifactArchiver;

    class Extras implements DressingRoom {
        prepare(actor: Actor): Actor {
            return actor;
        }
    }

    beforeEach(() => {
        fs = sinon.createStubInstance(FileSystem);
        fs.store.callsFake((path: Path, contents: any) => Promise.resolve(path));
    });

    describe('stores the artifacts generated by the other stage crew members', () => {

        beforeEach(() => {
            stage = new Stage(new Extras(), new StageManager(Duration.ofMilliseconds(250), new Clock()));

            archiver = new ArtifactArchiver(fs as any, stage);
            stage.assign(archiver);
        });

        const
            json = { key: 'value' },
            jsonArtifactName = new Name('expected-json-artifact-name'),
            pngArtifactName  = new Name('expected-png-artifact-name');

        /**
         * @test {ArtifactArchiver}
         * @test {ArtifactGenerated}
         */
        it('notifies the StageManager when an artifact is saved so that the promise of a stage cue can be fulfilled', () => {
            stage.announce(new ArtifactGenerated(
                jsonArtifactName,
                JSONData.fromJSON(json),
            ));

            return expect(stage.waitForNextCue()).to.be.fulfilled;
        });

        /**
         * @test {ArtifactArchiver}
         * @test {ArtifactGenerated}
         */
        it('notifies the StageManager when an artifact cannot be saved so that the promise of a stage cue can be rejected', () => {
            fs.store.returns(Promise.reject(new Error('Something happened')));

            stage.announce(new ArtifactGenerated(
                pngArtifactName,
                photo,
            ));

            return expect(stage.waitForNextCue()).to.be.rejected;
        });

        /**
         * @test {ArtifactArchiver}
         * @test {ArtifactGenerated}
         */
        it('correctly saves the test report to a unique file', () => {
            stage.announce(new ArtifactGenerated(
                jsonArtifactName,
                TestReport.fromJSON(json),
            ));

            return stage.waitForNextCue().then(() => {
                expect(fs.store).to.have.been.calledWith(
                    new Path(`scenario-report-b283bd69b0fcd75d754f678ac6685786.json`),
                    JSON.stringify(json),
                );
            });
        });

        /**
         * @test {ArtifactArchiver}
         * @test {ArtifactGenerated}
         */
        it('correctly saves PNG content to a file', () => {
            stage.announce(new ArtifactGenerated(
                pngArtifactName,
                photo,
            ));

            return stage.waitForNextCue().then(() => {
                expect(fs.store).to.have.been.calledWith(
                    new Path(`photo-4fdc8acbf8f6c958b2726fc8ae435bf5.png`),
                    photo.base64EncodedValue,
                    'base64',
                );
            });
        });
    });

    describe('when it encounters events it\'s not interested in', () => {

        class SomeEvent extends DomainEvent {
            constructor() {
                super();
            }
        }

        const someEvent = new SomeEvent();

        /**
         * @test {ArtifactArchiver}
         */
        it('ignores them', () => {
            const stageManager = sinon.createStubInstance(StageManager);

            fs           = sinon.createStubInstance(FileSystem);
            stage        = new Stage(new Extras(), stageManager as unknown as StageManager);

            archiver     = new ArtifactArchiver(fs as any);
            stage.assign(archiver);

            archiver.notifyOf(
                someEvent,
            );

            expect(stageManager.notifyOf).to.not.have.been.called;            // tslint:disable-line:no-unused-expression
            expect(fs.store).to.not.have.been.called;                         // tslint:disable-line:no-unused-expression
        });
    });

    /**
     * @test {ArtifactArchiver}
     * @test {ArtifactGenerated}
     * @test {ArtifactArchived}
     */
    it('notifies the StageManager when the artifact is correctly archived', () => {

        const stageManager = new StageManager(Duration.ofMilliseconds(250), new Clock());

        stage = new Stage(new Extras(), stageManager);

        archiver = new ArtifactArchiver(fs as any);
        stage.assign(archiver);

        const notifyOf = sinon.spy(stageManager, 'notifyOf');

        stageManager.notifyOf(new ArtifactGenerated(
            new Name('some report name'),
            TestReport.fromJSON({ key: 'value' }),
        ));

        return expect(stageManager.waitForNextCue()).to.be.fulfilled.then(() => {

            const archived: ArtifactArchived = notifyOf.getCall(2).lastArg;

            expect(archived).to.be.instanceOf(ArtifactArchived);
            expect(archived.name).to.equal(new Name('some report name'));
            expect(archived.type).to.equal(TestReport);
            expect(archived.path).to.equal(new Path('scenario-report-b283bd69b0fcd75d754f678ac6685786.json'));
        });
    });

    describe('when instantiated using a factory method', () => {
        it('joins the path segments provided so that the developer doesn\'t need to worry about cross-OS compatibility of the path', () => {
            archiver = ArtifactArchiver.storingArtifactsAt(process.cwd(), 'target', 'site/serenity');

            expect((archiver as any).fileSystem.root).to.equal(new Path(process.cwd()).join(new Path('target/site/serenity')));
        });

        it('complains if the destination is not provided', () => {
            expect(() => ArtifactArchiver.storingArtifactsAt()).to.throw(Error, 'Path to destination directory should have length that is greater than 0');
        });
    });
});
